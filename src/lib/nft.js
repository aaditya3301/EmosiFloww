import { ethers } from 'ethers';
import { decodeJWT } from '@/lib/jwt';

// PUBLIC TimeCapsuleNFT ABI - ANYONE CAN MINT! üåç
const SIMPLE_NFT_ABI = [
  // üåç PUBLIC MINT - Works for EVERYONE!
  "function mintTimeCapsule(address to, string memory encryptedBlobId, string memory metadataURI) public returns (uint256)",
  // View functions
  "function tokenURI(uint256 tokenId) public view returns (string memory)",
  "function getEncryptedBlobId(uint256 tokenId) public view returns (string memory)",
  "function getCreator(uint256 tokenId) public view returns (address)",
  "function name() public view returns (string memory)",
  "function symbol() public view returns (string memory)",
  "function totalSupply() public view returns (uint256)",
  "function nextTokenId() public view returns (uint256)",
  "function balanceOf(address owner) public view returns (uint256)",
  "function ownerOf(uint256 tokenId) public view returns (address)",
  // Transfer functions
  "function transferFrom(address from, address to, uint256 tokenId) public",
  "function safeTransferFrom(address from, address to, uint256 tokenId) public",
  "function approve(address to, uint256 tokenId) public",
  "function setApprovalForAll(address operator, bool approved) public",
  // Events
  "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",
  "event TimeCapsuleMinted(uint256 indexed tokenId, address indexed creator, address indexed to, string encryptedBlobId)"
];

// Production NFT Contract Address - NEW PUBLIC CONTRACT! üåç
const NFT_CONTRACT_ADDRESS = '0xfb42a2c4b5eb535cfe704ef64da416f1cf69bde3'; // ‚úÖ Your deployed public contract

const getContractAddress = () => {
  return NFT_CONTRACT_ADDRESS;
};

// Sepolia testnet configuration  
const SEPOLIA_RPC_URL = "https://sepolia.infura.io/v3/YOUR_INFURA_KEY"; // Replace with your RPC URL
const SEPOLIA_CHAIN_ID = 11155111;

// Always using real contract now
const isRealContract = () => {
  return true;
};

// Get wallet address from JWT
const getWalletFromJWT = () => {
  const jwt = localStorage.getItem('wallet-jwt');
  if (!jwt) {
    throw new Error('No wallet JWT found. Please connect your wallet.');
  }
  
  const decoded = decodeJWT(jwt);
  if (!decoded || !decoded.walletAddress) {
    throw new Error('Invalid JWT or wallet address not found. Please reconnect your wallet.');
  }
  
  return decoded.walletAddress;
};

/**
 * Mint NFT with encrypted blob ID as metadata
 * @param {string} walletAddress - User's wallet address
 * @param {string} encryptedBlobId - Encrypted blob ID from Walrus
 * @param {string} capsuleId - Unique capsule identifier
 * @param {object} metadata - Additional metadata for the NFT
 * @returns {Promise<{success: boolean, txHash?: string, tokenId?: number, error?: string}>}
 */
export async function mintTimeCapsuleNFT(encryptedBlobId, capsuleId, metadata = {}) {
  try {
    // Get wallet address from JWT instead of parameter
    const walletAddress = getWalletFromJWT();
    const contractAddress = getContractAddress();
    const useRealContract = isRealContract();
    
    // Check if MetaMask is available
    if (!window.ethereum) {
      throw new Error('MetaMask not found. Please install MetaMask.');
    }

    // Request account access
    await window.ethereum.request({ method: 'eth_requestAccounts' });

    // Check if we're on Sepolia testnet FIRST
    const initialProvider = new ethers.BrowserProvider(window.ethereum);
    const initialNetwork = await initialProvider.getNetwork();
    
    if (initialNetwork.chainId !== BigInt(SEPOLIA_CHAIN_ID)) {
      console.log('üîÑ Switching to Sepolia testnet...');
      const switched = await switchToSepolia();
      if (!switched) {
        throw new Error('Please switch to Sepolia testnet manually');
      }
      
      // Wait for network to stabilize after switch
      await new Promise(resolve => setTimeout(resolve, 3000));
    }
    
    // Create NEW provider and signer after network is confirmed
    const provider = new ethers.BrowserProvider(window.ethereum);
    const signer = await provider.getSigner();
    
    // Double-check we're on Sepolia
    const finalNetwork = await provider.getNetwork();
    if (finalNetwork.chainId !== BigInt(SEPOLIA_CHAIN_ID)) {
      throw new Error(`‚ùå Wrong network. Expected Sepolia (${SEPOLIA_CHAIN_ID}) but got ${finalNetwork.chainId}`);
    }
    
    console.log('‚úÖ Confirmed on Sepolia testnet');

    // No owner restrictions - PUBLIC CONTRACT! üåç
    console.log('üåç Using PUBLIC Time Capsule contract - ANYONE CAN MINT!');
    console.log('ÔøΩ Contract Address:', contractAddress);

    // Token ID will be generated by the contract automatically
    
    // Create metadata JSON
    const nftMetadata = {
      name: `Time Capsule #${capsuleId}`,
      description: `A decentralized time capsule storing encrypted content on Walrus network`,
      image: "https://via.placeholder.com/400x400.png?text=Time+Capsule", // Placeholder image
      attributes: [
        {
          trait_type: "Capsule ID",
          value: capsuleId
        },
        {
          trait_type: "Encrypted Content",
          value: encryptedBlobId
        },
        {
          trait_type: "Created",
          value: new Date().toISOString()
        },
        ...Object.entries(metadata).map(([key, value]) => ({
          trait_type: key,
          value: value
        }))
      ],
      // Store encrypted blob ID in metadata
      encryptedBlobId: encryptedBlobId,
      capsuleId: capsuleId
    };

    // For now, we'll store metadata as JSON string (in production, upload to IPFS)
    const metadataURI = `data:application/json;base64,${btoa(JSON.stringify(nftMetadata))}`;

    if (useRealContract) {
      console.log('ÔøΩ Minting REAL NFT with PUBLIC contract:');
      console.log('üìç Contract Address:', contractAddress);
      console.log('üë§ Wallet:', walletAddress);
      console.log('üîê Encrypted Blob ID:', encryptedBlobId);
      console.log('üéØ ANYONE can mint on this contract!');

      // Create contract instance
      const contract = new ethers.Contract(contractAddress, SIMPLE_NFT_ABI, signer);

      // Estimate gas before sending transaction
      console.log('‚õΩ Estimating gas for NFT mint...');
      try {
        const gasEstimate = await contract.mintTimeCapsule.estimateGas(walletAddress, encryptedBlobId, metadataURI);
        console.log('üìä Estimated gas:', gasEstimate.toString());

        // Mint the NFT with gas buffer
        console.log('üöÄ Sending mint transaction...');
        const tx = await contract.mintTimeCapsule(walletAddress, encryptedBlobId, metadataURI, {
          gasLimit: gasEstimate * BigInt(120) / BigInt(100) // Add 20% buffer
        });
        
        console.log('‚úÖ Transaction sent:', tx.hash);
        console.log('‚è≥ Waiting for confirmation...');

        // Wait for transaction confirmation with timeout
        const receipt = await Promise.race([
          tx.wait(1), // Wait for 1 confirmation
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Transaction timeout after 60 seconds')), 60000)
          )
        ]);
        
        // Extract token ID from transaction receipt
        let tokenId = Date.now(); // Fallback token ID
        if (receipt.logs && receipt.logs.length > 0) {
          try {
            // Parse logs to get token ID
            for (const log of receipt.logs) {
              if (log.topics[0] === ethers.id("Transfer(address,address,uint256)")) {
                tokenId = parseInt(log.topics[3], 16);
                break;
              }
            }
          } catch (parseError) {
            console.warn('Could not parse token ID from logs, using fallback');
          }
        }
        
        console.log('üéâ REAL NFT minted successfully!');
        console.log('üìÑ Transaction Hash:', receipt.hash);
        console.log('üè∑Ô∏è Token ID:', tokenId);
        console.log('‚õΩ Gas Used:', receipt.gasUsed.toString());
        console.log('üèóÔ∏è Block Number:', receipt.blockNumber);
        console.log('üåç This NFT will show up in your wallet!');

        return {
          success: true,
          txHash: receipt.hash,
          tokenId: tokenId,
          contractAddress: contractAddress,
          metadataURI: metadataURI,
          real: true,
          message: 'üéâ Real NFT minted successfully! Check your wallet!'
        };
        
      } catch (gasError) {
        console.error('Gas estimation failed:', gasError);
        throw new Error(`Gas estimation failed: ${gasError.message}`);
      }

    } else {
      // Demo mode - simulate minting
      // Generate fake token ID for demo
      const fakeTokenId = Date.now();
      
      console.log('üé® Simulating NFT mint (demo mode - using real contract now):');
      console.log('- Token ID:', fakeTokenId);
      console.log('- Wallet:', walletAddress);
      console.log('- Encrypted Blob ID:', encryptedBlobId);

      // DEMO: Simulate transaction delay
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Generate fake transaction hash for demo
      const fakeHash = '0x' + Array.from({length: 64}, () => Math.floor(Math.random() * 16).toString(16)).join('');

      console.log('‚úÖ NFT minted successfully! (DEMO MODE)');
      console.log('Transaction Hash (DEMO):', fakeHash);

      return {
        success: true,
        txHash: fakeHash,
        tokenId: fakeTokenId,
        contractAddress: contractAddress,
        metadataURI: metadataURI,
        demo: true // Flag to indicate this is demo mode
      };
    }

  } catch (error) {
    console.error('‚ùå NFT Minting Error:', error);
    
    let errorMessage = 'Failed to mint NFT';
    
    // Handle specific error types
    if (error.message.includes('user rejected') || error.code === 4001) {
      errorMessage = 'Transaction rejected by user';
    } else if (error.message.includes('insufficient funds')) {
      errorMessage = 'Insufficient ETH for gas fees. You need at least 0.01 ETH.';
    } else if (error.message.includes('network changed') || error.code === 'NETWORK_ERROR') {
      errorMessage = 'Network changed during transaction. Please try again and keep MetaMask on Sepolia.';
    } else if (error.message.includes('Gas estimation failed')) {
      errorMessage = 'Transaction failed: ' + error.message;
    } else if (error.message.includes('Ownable: caller is not the owner') || error.message.includes('onlyOwner')) {
      errorMessage = 'üö´ PERMISSION DENIED: This contract only allows the owner to mint NFTs.\n\nüí° SOLUTION: Deploy a new "Public Time Capsule" contract that allows ANYONE to mint!';
    } else if (error.message.includes('MetaMask')) {
      errorMessage = error.message;
    } else if (error.message.includes('Sepolia') || error.message.includes('Wrong network')) {
      errorMessage = error.message;
    } else if (error.message.includes('timeout')) {
      errorMessage = 'Transaction timed out. Please check Etherscan and try again if needed.';
    } else if (error.message.includes('JWT') || error.message.includes('wallet session')) {
      errorMessage = error.message;
    }

    return {
      success: false,
      error: errorMessage
    };
  }
}

/**
 * Switch to Sepolia testnet if not already connected
 * @returns {Promise<boolean>} Success status
 */
export async function switchToSepolia() {
  try {
    console.log('üîÑ Attempting to switch to Sepolia testnet...');
    
    await window.ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: '0xAA36A7' }], // Sepolia chain ID in hex
    });
    
    // Wait for network switch to complete
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Verify the switch worked
    const provider = new ethers.BrowserProvider(window.ethereum);
    const network = await provider.getNetwork();
    
    if (network.chainId === BigInt(SEPOLIA_CHAIN_ID)) {
      console.log('‚úÖ Successfully switched to Sepolia testnet');
      return true;
    } else {
      console.error('‚ùå Network switch failed, still on chain:', network.chainId.toString());
      return false;
    }
    
  } catch (error) {
    console.error('Failed to switch to Sepolia:', error);
    
    if (error.code === 4902) {
      // Chain not added to MetaMask
      try {
        console.log('üì° Adding Sepolia network to MetaMask...');
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: '0xAA36A7',
            chainName: 'Sepolia Testnet',
            nativeCurrency: {
              name: 'ETH',
              symbol: 'ETH',
              decimals: 18,
            },
            rpcUrls: ['https://sepolia.infura.io/v3/'],
            blockExplorerUrls: ['https://sepolia.etherscan.io/'],
          }],
        });
        console.log('‚úÖ Sepolia network added successfully');
        return true;
      } catch (addError) {
        console.error('‚ùå Failed to add Sepolia network:', addError);
        return false;
      }
    }
    
    return false;
  }
}

/**
 * Get Sepolia testnet ETH from faucet (informational)
 * @returns {string[]} Array of faucet URLs
 */
export function getSepoliaFaucets() {
  return [
    'https://sepoliafaucet.com/',
    'https://www.alchemy.com/faucets/ethereum-sepolia',
    'https://sepolia-faucet.pk910.de/'
  ];
}